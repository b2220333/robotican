/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2017-03-06 11:00:40.331317
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25;
x0=IKsin(j[0]);
x1=IKsin(j[2]);
x2=IKcos(j[0]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKcos(j[3]);
x6=IKcos(j[1]);
x7=IKsin(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=((0.224)*x3);
x11=((0.30475)*x7);
x12=((1.0)*x7);
x13=((0.0131)*x3);
x14=((1.0)*x3);
x15=((1.0)*x5);
x16=(x0*x1);
x17=(x2*x4);
x18=(x4*x5);
x19=(x1*x2);
x20=(x2*x6);
x21=(x0*x4);
x22=(x3*x6);
x23=(x0*x6);
x24=((0.30475)*x3*x4);
x25=((0.0131)*x5*x6);
eetrans[0]=((0.113)+((x7*(((((0.0131)*x16))+(((-1.0)*x13*x17))))))+(((0.26631)*x17))+(((-0.224)*x16))+((x5*(((((0.30475)*x17*x3))+(((-0.30475)*x16))))))+((x11*x20))+((x10*x17))+(((0.00025)*x0))+(((0.0131)*x20*x5)));
eetrans[1]=((((-0.00025)*x2))+(((0.26631)*x21))+((x7*(((((-1.0)*x13*x21))+(((-0.0131)*x19))))))+(((0.224)*x19))+(((0.0131)*x23*x5))+((x11*x23))+((x10*x21))+((x5*(((((0.30475)*x21*x3))+(((0.30475)*x19)))))));
eetrans[2]=((0.0795)+(((-1.0)*x11*x4))+(((0.26631)*x6))+(((-0.0131)*x18))+(((-1.0)*x13*x6*x7))+((x10*x6))+(((0.30475)*x22*x5)));
IkReal x26=((1.0)*x17);
eerot[0]=((((-1.0)*x9*((((x12*(((((-1.0)*x14*x26))+x16))))+((x15*x20))))))+((x8*((((x0*x14))+((x1*x26)))))));
IkReal x27=((1.0)*x14);
eerot[1]=(((x8*(((((1.0)*x16*x4))+(((-1.0)*x2*x27))))))+(((-1.0)*x9*((((x12*(((((-1.0)*x21*x27))+(((-1.0)*x19))))))+((x15*x23)))))));
eerot[2]=(((x9*((((x12*x22))+((x15*x4))))))+((x1*x6*x8)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=((-0.113)+px);
new_r01=r01;
new_py=py;
new_r02=r02;
new_pz=((-0.0795)+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
IkReal op[72], zeror[48];
int numroots;;
IkReal x28=((0.0005)*py);
IkReal x29=((0.98062)*pz);
IkReal x30=((0.08462)*pz);
IkReal x31=px*px;
IkReal x32=pz*pz;
IkReal x33=py*py;
IkReal x34=((0.1473596611)*r01);
IkReal x35=((0.000245155)*r02);
IkReal x36=((0.1137891261)*r02);
IkReal x37=((0.00489135090864643)*r00);
IkReal x38=((0.000133155)*r01);
IkReal x39=((0.2275782522)*r00);
IkReal x40=((0.00978270181729286)*r02);
IkReal x41=((2.1155e-5)*r02);
IkReal x42=((0.0912540989)*r01);
IkReal x43=((0.001)*px);
IkReal x44=((0.2947193222)*r00);
IkReal x45=((0.00026631)*r00);
IkReal x46=((0.00978270181729286)*r01);
IkReal x47=((0.4551565044)*r01);
IkReal x48=((0.1825081978)*r00);
IkReal x49=((0.448)*py);
IkReal x50=((0.000112)+(((-1.0)*x49)));
IkReal x51=((0.00049031)*r00);
IkReal x52=((4.231e-5)*r00);
IkReal x53=((0.0859721082854799)*r02);
IkReal x54=((4.0)*r01);
IkReal x55=(px*py);
IkReal x56=((1.0)*r02);
IkReal x57=(pz*r02);
IkReal x58=(py*r00);
IkReal x59=(px*r00);
IkReal x60=(py*r02);
IkReal x61=(pz*r00);
IkReal x62=((1.0)*r01);
IkReal x63=(pz*r01);
IkReal x64=((0.0859721082854799)*r01);
IkReal x65=((0.16924)*px);
IkReal x66=(px*r01);
IkReal x67=((2.0)*r00);
IkReal x68=((0.0429860541427399)*r00);
IkReal x69=((2.0)*py);
IkReal x70=(px*r02);
IkReal x71=((0.17194421657096)*py);
IkReal x72=((1.0)*x31);
IkReal x73=((1.0)*x33);
IkReal x74=((1.0)*x32);
IkReal x75=((0.000112)+x49);
IkReal x76=(r01*x31);
IkReal x77=(r01*x32);
IkReal x78=(r01*x29);
IkReal x79=((0.0005)*x59);
IkReal x80=((0.0005)*x57);
IkReal x81=(r01*x28);
IkReal x82=((0.98062)*x60);
IkReal x83=((2.149302707137e-5)*x66);
IkReal x84=(r02*x28);
IkReal x85=((0.0228952321575062)*x70);
IkReal x86=((0.0228952321575062)*x61);
IkReal x87=((0.0005)*x63);
IkReal x88=((0.53262)*x59);
IkReal x89=((0.53262)*x57);
IkReal x90=((2.149302707137e-5)*x58);
IkReal x91=((0.53262)*py*r01);
IkReal x92=(r02*x33);
IkReal x93=(r02*x31);
IkReal x94=((0.001)*x58);
IkReal x95=((4.298605414274e-5)*x63);
IkReal x96=(r01*x43);
IkReal x97=((4.298605414274e-5)*x60);
IkReal x98=(r02*x32);
IkReal x99=(r01*x30);
IkReal x100=((0.08462)*x60);
IkReal x101=((-0.896)*px);
IkReal x102=((1.96124)*x70);
IkReal x103=((1.96124)*x61);
IkReal x104=((0.0457904643150123)*x60);
IkReal x105=((0.001)*x61);
IkReal x106=((0.0457904643150123)*x63);
IkReal x107=(r02*x43);
IkReal x108=((8.59721082854799e-5)*x70);
IkReal x109=((8.59721082854799e-5)*x61);
IkReal x110=(r02*x65);
IkReal x111=((0.16924)*x61);
IkReal x112=((1.96124)*x58);
IkReal x113=((1.96124)*x66);
IkReal x114=(r01*x33);
IkReal x115=((0.16924)*x58);
IkReal x116=(r01*x65);
IkReal x117=((0.0912539739)+x30);
IkReal x118=((-0.1473597861)+x28);
IkReal x119=(r00*x33);
IkReal x120=(x55*x67);
IkReal x121=(x33*x62);
IkReal x122=(x57*x69);
IkReal x123=(x55*x64);
IkReal x124=(px*pz*x53);
IkReal x125=(x31*x68);
IkReal x126=(x32*x68);
IkReal x127=((2.0)*pz*x59);
IkReal x128=(x33*x68);
IkReal x129=(x63*x69);
IkReal x130=(x32*x56);
IkReal x131=((0.17194421657096)*pz*x59);
IkReal x132=(x63*x71);
IkReal x133=(x32*x53);
IkReal x134=(x32*x67);
IkReal x135=(x33*x67);
IkReal x136=(x31*x67);
IkReal x137=(x31*x53);
IkReal x138=(x33*x53);
IkReal x139=((4.0)*px*x57);
IkReal x140=(x54*x55);
IkReal x141=(x33*x56);
IkReal x142=(x31*x56);
IkReal x143=(x57*x71);
IkReal x144=(x33*x64);
IkReal x145=((0.17194421657096)*r00*x55);
IkReal x146=(x32*x64);
IkReal x147=(x31*x64);
IkReal x148=(x32*x54);
IkReal x149=(x31*x54);
IkReal x150=((8.0)*py*x57);
IkReal x151=((8.0)*r00*x55);
IkReal x152=(x33*x54);
IkReal x153=(x32*x62);
IkReal x154=(x31*x62);
IkReal x155=(x78+x35);
IkReal x156=(x105+x45);
IkReal x157=(x38+x84);
IkReal x158=(x100+x41);
IkReal x159=(x34+x82);
IkReal x160=(x107+x45);
IkReal x161=(x114+x42);
IkReal x162=(x41+x99);
IkReal x163=(x95+x94);
IkReal x164=(x77+x76);
IkReal x165=(x93+x92);
IkReal x166=(x86+x87);
IkReal x167=(x95+x96);
IkReal x168=(x85+x90);
IkReal x169=(x83+x84);
IkReal x170=(x87+x98);
IkReal x171=(x97+x96);
IkReal x172=(x87+x85);
IkReal x173=(x94+x97);
IkReal x174=(x135+x134);
IkReal x175=(x122+x120);
IkReal x176=(x141+x142);
IkReal x177=(x148+x149);
IkReal x178=(x74+x73+x72);
IkReal x179=(x88+x89+x91);
IkReal x180=(x137+x138+x40);
IkReal x181=(x146+x147+x46);
IkReal x182=(x126+x128+x37);
IkReal x183=(x127+x129+x36);
IkReal x184=(x178+x28);
IkReal x185=(x140+x136+x139);
IkReal x186=(x131+x133+x132);
IkReal x187=(x143+x144+x145);
IkReal x188=(x124+x125+x123);
IkReal x189=(x121+x79+x80+x81);
IkReal x190=(x152+x151+x150+x47);
IkReal x191=(x188+x90);
IkReal x192=(x182+x38+x83);
IkReal x193=(x183+x86+x98);
IkReal x194=(x154+x153+x79+x80+x81);
IkReal x195=(x130+x183+x84+x85);
op[0]=((-0.1473597861)+(((-1.0)*x184))+x29);
op[1]=x75;
op[2]=((1.96124)*px);
op[3]=0;
op[4]=((-0.1473597861)+(((-1.0)*x29))+(((-1.0)*x184)));
op[5]=x75;
op[6]=x75;
op[7]=((((-1.0)*x184))+x117);
op[8]=0;
op[9]=x65;
op[10]=x75;
op[11]=((0.0912539739)+(((-1.0)*x184))+(((-1.0)*x30)));
op[12]=((((-1.0)*x78))+(((-1.0)*x175))+(((-1.0)*x189))+x164+x159+x35);
op[13]=((((-1.0)*x157))+(((-1.0)*x179))+(((-1.0)*x176))+(((-1.0)*x188))+x170+x168+x182+x183+(((-1.0)*x86))+(((-1.0)*x83)));
op[14]=((((-1.0)*x113))+x112+x51);
op[15]=((((-1.0)*x174))+(((-1.0)*x173))+(((-1.0)*x180))+x167+x185+x186+x39);
op[16]=((((-1.0)*x175))+(((-1.0)*x189))+(((-1.0)*x35))+x164+x78+x34+(((-1.0)*x82)));
op[17]=((((-1.0)*x166))+(((-1.0)*x179))+(((-1.0)*x183))+(((-1.0)*x182))+(((-1.0)*x38))+x169+x165+x188+(((-1.0)*x130))+x85+(((-1.0)*x90)));
op[18]=((((-1.0)*x166))+(((-1.0)*x183))+(((-1.0)*x188))+x179+x168+x165+x157+x182+(((-1.0)*x130))+(((-1.0)*x83)));
op[19]=((((-1.0)*x175))+(((-1.0)*x42))+(((-1.0)*x189))+x164+x158+(((-1.0)*x99)));
op[20]=((((-1.0)*x171))+(((-1.0)*x180))+(((-1.0)*x185))+(((-1.0)*x39))+x174+x163+x186);
op[21]=((((-1.0)*x116))+x115+x52);
op[22]=((((-1.0)*x176))+(((-1.0)*x182))+x179+x170+x183+x188+x38+x83+x85+(((-1.0)*x90))+(((-1.0)*x84))+(((-1.0)*x86)));
op[23]=((((-1.0)*x158))+(((-1.0)*x175))+(((-1.0)*x42))+(((-1.0)*x189))+x164+x99);
op[24]=x43;
op[25]=x101;
op[26]=((3.92248)*py);
op[27]=0;
op[28]=x43;
op[29]=x101;
op[30]=x101;
op[31]=x43;
op[32]=0;
op[33]=((0.33848)*py);
op[34]=x101;
op[35]=x43;
op[36]=((((-1.0)*x174))+(((-1.0)*x44))+(((-1.0)*x102))+x103+x185);
op[37]=((((-1.0)*x187))+(((-1.0)*x106))+(((-1.0)*x105))+x160+x104+x181);
op[38]=((0.00098062)*r01);
op[39]=((((-1.0)*x177))+(((-1.0)*x109))+x108+x190);
op[40]=((((-1.0)*x174))+(((-1.0)*x44))+(((-1.0)*x103))+x102+x185);
op[41]=((((-1.0)*x181))+(((-1.0)*x107))+(((-1.0)*x106))+x156+x104+x187);
op[42]=((((-1.0)*x160))+(((-1.0)*x187))+(((-1.0)*x106))+x104+x105+x181);
op[43]=((((-1.0)*x174))+(((-1.0)*x110))+x111+x185+x48);
op[44]=((((-1.0)*x109))+(((-1.0)*x190))+x177+x108);
op[45]=((8.462e-5)*r01);
op[46]=((((-1.0)*x156))+(((-1.0)*x181))+(((-1.0)*x106))+x104+x107+x187);
op[47]=((((-1.0)*x174))+(((-1.0)*x111))+x110+x185+x48);
op[48]=((((-1.0)*x178))+x118+x29);
op[49]=x50;
op[50]=((-1.96124)*px);
op[51]=0;
op[52]=((((-1.0)*x29))+(((-1.0)*x178))+x118);
op[53]=x50;
op[54]=x50;
op[55]=((((-1.0)*x178))+x117+x28);
op[56]=0;
op[57]=((-0.16924)*px);
op[58]=x50;
op[59]=((0.0912539739)+(((-1.0)*x178))+(((-1.0)*x30))+x28);
op[60]=((((-1.0)*x159))+(((-1.0)*x194))+x175+x155+x114);
op[61]=((((-1.0)*x179))+(((-1.0)*x176))+(((-1.0)*x172))+(((-1.0)*x182))+x157+x193+x191+(((-1.0)*x83)));
op[62]=((((-1.0)*x113))+x112+(((-1.0)*x51)));
op[63]=((((-1.0)*x163))+(((-1.0)*x180))+(((-1.0)*x185))+(((-1.0)*x39))+x171+x174+x186);
op[64]=((((-1.0)*x155))+(((-1.0)*x34))+(((-1.0)*x194))+x175+x114+x82);
op[65]=((((-1.0)*x168))+(((-1.0)*x179))+(((-1.0)*x183))+(((-1.0)*x188))+x166+x165+x192+(((-1.0)*x130))+(((-1.0)*x84)));
op[66]=((((-1.0)*x157))+(((-1.0)*x183))+(((-1.0)*x182))+x179+x166+x165+x191+(((-1.0)*x130))+(((-1.0)*x83))+(((-1.0)*x85)));
op[67]=((((-1.0)*x100))+(((-1.0)*x194))+x175+x162+x161);
op[68]=((((-1.0)*x167))+(((-1.0)*x174))+(((-1.0)*x180))+x173+x185+x186+x39);
op[69]=((((-1.0)*x116))+x115+(((-1.0)*x52)));
op[70]=((((-1.0)*x168))+(((-1.0)*x176))+(((-1.0)*x188))+(((-1.0)*x38))+x179+x169+x193+x182+(((-1.0)*x87)));
op[71]=((((-1.0)*x162))+(((-1.0)*x194))+x175+x161+x100);
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j1array[16], cj1array[16], sj1array[16], j2array[16], cj2array[16], sj2array[16], j3array[16], cj3array[16], sj3array[16];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ij1 += 3)
{
IkReal htj1 = zeror[ij1+0], htj2 = zeror[ij1+1], htj3 = zeror[ij1+2];
if(isnan(htj1)||isnan(htj2)||isnan(htj3)){
continue;
}
j1array[numsolutions]=((2.0)*(atan(htj1)));
j2array[numsolutions]=((2.0)*(atan(htj2)));
j3array[numsolutions]=((2.0)*(atan(htj3)));
if(isinf(htj1)){
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
}
else{
IkReal x196=htj1*htj1;
CheckValue<IkReal> x197=IKPowWithIntegerCheck(((1.0)+x196),-1);
if(!x197.valid){
continue;
}
cj1array[numsolutions]=((x197.value)*(((1.0)+(((-1.0)*x196)))));
CheckValue<IkReal> x198=IKPowWithIntegerCheck(((1.0)+(htj1*htj1)),-1);
if(!x198.valid){
continue;
}
sj1array[numsolutions]=((2.0)*htj1*(x198.value));
}
if(isinf(htj2)){
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
}
else{
IkReal x199=htj2*htj2;
CheckValue<IkReal> x200=IKPowWithIntegerCheck(((1.0)+x199),-1);
if(!x200.valid){
continue;
}
cj2array[numsolutions]=((x200.value)*(((1.0)+(((-1.0)*x199)))));
CheckValue<IkReal> x201=IKPowWithIntegerCheck(((1.0)+(htj2*htj2)),-1);
if(!x201.valid){
continue;
}
sj2array[numsolutions]=((2.0)*htj2*(x201.value));
}
if(isinf(htj3)){
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
}
else{
IkReal x202=htj3*htj3;
CheckValue<IkReal> x203=IKPowWithIntegerCheck(((1.0)+x202),-1);
if(!x203.valid){
continue;
}
cj3array[numsolutions]=((x203.value)*(((1.0)+(((-1.0)*x202)))));
CheckValue<IkReal> x204=IKPowWithIntegerCheck(((1.0)+(htj3*htj3)),-1);
if(!x204.valid){
continue;
}
sj3array[numsolutions]=((2.0)*htj3*(x204.value));
}
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j1valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj1 = 16;
_nj2 = 1;
_nj3 = 1;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
_ij2[0] = 0; _ij2[1] = -1;
_ij3[0] = 0; _ij3[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( !j1valid[iij1] ) { continue; }
if( IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(cj2array[ij1]-cj2array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij1]-sj2array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(cj3array[ij1]-cj3array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij1]-sj3array[iij1]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j1valid[iij1]=false; _ij1[1] = iij1; _ij2[1] = 0; _ij3[1] = 0;  break; 
}
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

    j2 = j2array[ij1]; cj2 = cj2array[ij1]; sj2 = sj2array[ij1];

    j3 = j3array[ij1]; cj3 = cj3array[ij1]; sj3 = sj3array[ij1];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=IKsign(sj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=cj3;
j4eval[1]=IKsign(cj3);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x205=((3.27532602861291)*cj1);
IkReal x206=(cj2*px);
IkReal x207=(px*sj1);
IkReal x208=((0.14079334200108)*py);
IkReal x209=(pz*sj2);
IkReal x210=(cj2*sj1);
if( IKabs(((0.0315025102727417)+(((-1.0)*cj1*x208))+((x205*x206))+(((3.27532602861291)*py*x210))+(((0.14079334200108)*x207))+(((-3.27532602861291)*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73285419890214)+(((-0.14079334200108)*x209))+((x208*x210))+(((0.14079334200108)*cj1*x206))+((py*x205))+(((-3.27532602861291)*x207)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0315025102727417)+(((-1.0)*cj1*x208))+((x205*x206))+(((3.27532602861291)*py*x210))+(((0.14079334200108)*x207))+(((-3.27532602861291)*x209))))+IKsqr(((-0.73285419890214)+(((-0.14079334200108)*x209))+((x208*x210))+(((0.14079334200108)*cj1*x206))+((py*x205))+(((-3.27532602861291)*x207))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0315025102727417)+(((-1.0)*cj1*x208))+((x205*x206))+(((3.27532602861291)*py*x210))+(((0.14079334200108)*x207))+(((-3.27532602861291)*x209))), ((-0.73285419890214)+(((-0.14079334200108)*x209))+((x208*x210))+(((0.14079334200108)*cj1*x206))+((py*x205))+(((-3.27532602861291)*x207))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x211=IKcos(j4);
IkReal x212=IKsin(j4);
IkReal x213=((1.0)*sj1);
evalcond[0]=((-0.22375)+(((-0.30475)*x211))+(((-1.0)*px*x213))+((cj1*py))+(((0.0131)*x212)));
evalcond[1]=((((0.0131)*x211))+(((0.30475)*x212))+(((-1.0)*cj2*py*x213))+((pz*sj2))+(((-1.0)*cj1*cj2*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((cj1*r01))+(((-1.0)*r00*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((r00*sj1))+(((-1.0)*cj1*r01))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x214=(r01*sj1);
IkReal x215=((1.0)*cj2);
IkReal x216=(cj1*r00);
if( IKabs((((sj2*x214))+((sj2*x216))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj2))+(((-1.0)*x214*x215))+(((-1.0)*x215*x216)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x214))+((sj2*x216))+((cj2*r02))))+IKsqr((((r02*sj2))+(((-1.0)*x214*x215))+(((-1.0)*x215*x216))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x214))+((sj2*x216))+((cj2*r02))), (((r02*sj2))+(((-1.0)*x214*x215))+(((-1.0)*x215*x216))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x217=(r01*sj1);
IkReal x218=((1.0)*cj2);
IkReal x219=(cj1*r00);
evalcond[0]=(((sj2*x217))+((sj2*x219))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*(IKcos(j5))))+(((-1.0)*x218*x219))+((r02*sj2))+(((-1.0)*x217*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x220=(cj1*r00);
IkReal x221=(r01*sj1);
if( IKabs((((sj2*x221))+((sj2*x220))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*x221))+((cj2*x220))+(((-1.0)*r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x221))+((sj2*x220))+((cj2*r02))))+IKsqr((((cj2*x221))+((cj2*x220))+(((-1.0)*r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x221))+((sj2*x220))+((cj2*r02))), (((cj2*x221))+((cj2*x220))+(((-1.0)*r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x222=(r01*sj1);
IkReal x223=((1.0)*cj2);
IkReal x224=(cj1*r00);
evalcond[0]=((((-1.0)*x222*x223))+((r02*sj2))+(IKcos(j5))+(((-1.0)*x223*x224)));
evalcond[1]=(((sj2*x222))+((sj2*x224))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x225=(r01*sj1);
IkReal x226=((1.0)*cj2);
IkReal x227=(cj1*r00);
CheckValue<IkReal> x228=IKPowWithIntegerCheck(cj4,-1);
if(!x228.valid){
continue;
}
if( IKabs((((sj2*x225))+((sj2*x227))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x228.value)*(((((-1.0)*x225*x226))+((r02*sj2))+(((-1.0)*x226*x227)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x225))+((sj2*x227))+((cj2*r02))))+IKsqr(((x228.value)*(((((-1.0)*x225*x226))+((r02*sj2))+(((-1.0)*x226*x227))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x225))+((sj2*x227))+((cj2*r02))), ((x228.value)*(((((-1.0)*x225*x226))+((r02*sj2))+(((-1.0)*x226*x227))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x229=IKcos(j5);
IkReal x230=(r01*sj1);
IkReal x231=((1.0)*cj2);
IkReal x232=(cj1*r00);
IkReal x233=((1.0)*x229);
evalcond[0]=((((-1.0)*sj4*x233))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((sj2*x232))+((sj2*x230))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
evalcond[2]=((((-1.0)*x230*x231))+(((-1.0)*cj4*x233))+((r02*sj2))+(((-1.0)*x231*x232)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x234=IKPowWithIntegerCheck(sj4,-1);
if(!x234.valid){
continue;
}
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x234.value)*((((cj1*r01))+(((-1.0)*r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr(((x234.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), ((x234.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x235=IKcos(j5);
IkReal x236=(r01*sj1);
IkReal x237=((1.0)*cj2);
IkReal x238=(cj1*r00);
IkReal x239=((1.0)*x235);
evalcond[0]=((((-1.0)*sj4*x239))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((sj2*x238))+((sj2*x236))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
evalcond[2]=((((-1.0)*cj4*x239))+((r02*sj2))+(((-1.0)*x236*x237))+(((-1.0)*x237*x238)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x240=((3.27532602861291)*cj1);
IkReal x241=(cj2*px);
IkReal x242=(px*sj1);
IkReal x243=((0.14079334200108)*py);
IkReal x244=(pz*sj2);
IkReal x245=(cj2*sj1);
if( IKabs(((0.0315729069437422)+((x240*x241))+(((-0.14079334200108)*x242))+((cj1*x243))+(((3.27532602861291)*py*x245))+(((-3.27532602861291)*x244)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.734491861916446)+(((-0.14079334200108)*x244))+(((3.27532602861291)*x242))+(((0.14079334200108)*cj1*x241))+((x243*x245))+(((-1.0)*py*x240)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0315729069437422)+((x240*x241))+(((-0.14079334200108)*x242))+((cj1*x243))+(((3.27532602861291)*py*x245))+(((-3.27532602861291)*x244))))+IKsqr(((-0.734491861916446)+(((-0.14079334200108)*x244))+(((3.27532602861291)*x242))+(((0.14079334200108)*cj1*x241))+((x243*x245))+(((-1.0)*py*x240))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0315729069437422)+((x240*x241))+(((-0.14079334200108)*x242))+((cj1*x243))+(((3.27532602861291)*py*x245))+(((-3.27532602861291)*x244))), ((-0.734491861916446)+(((-0.14079334200108)*x244))+(((3.27532602861291)*x242))+(((0.14079334200108)*cj1*x241))+((x243*x245))+(((-1.0)*py*x240))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x246=IKcos(j4);
IkReal x247=IKsin(j4);
IkReal x248=((1.0)*sj1);
evalcond[0]=((0.22425)+(((-0.0131)*x247))+((cj1*py))+(((-1.0)*px*x248))+(((0.30475)*x246)));
evalcond[1]=((((0.0131)*x246))+((pz*sj2))+(((-1.0)*cj2*py*x248))+(((-1.0)*cj1*cj2*px))+(((0.30475)*x247)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x249=((1.0)*r01);
if( IKabs(((((-1.0)*sj1*sj2*x249))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*x249)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*sj2*x249))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*x249))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj1*sj2*x249))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))), (((r00*sj1))+(((-1.0)*cj1*x249))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x250=((1.0)*sj1);
if( IKabs(((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x250))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01))+(((-1.0)*r00*x250)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x250))+(((-1.0)*cj2*r02))))+IKsqr((((cj1*r01))+(((-1.0)*r00*x250))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x250))+(((-1.0)*cj2*r02))), (((cj1*r01))+(((-1.0)*r00*x250))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x251=((1.0)*sj2);
IkReal x252=(cj1*r00);
IkReal x253=((1.0)*cj2);
IkReal x254=(r01*sj1);
if( IKabs(((((-1.0)*x251*x252))+(((-1.0)*x251*x254))+(((-1.0)*r02*x253)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x252*x253))+((r02*sj2))+(((-1.0)*x253*x254)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x251*x252))+(((-1.0)*x251*x254))+(((-1.0)*r02*x253))))+IKsqr(((((-1.0)*x252*x253))+((r02*sj2))+(((-1.0)*x253*x254))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x251*x252))+(((-1.0)*x251*x254))+(((-1.0)*r02*x253))), ((((-1.0)*x252*x253))+((r02*sj2))+(((-1.0)*x253*x254))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x255=(r01*sj1);
IkReal x256=((1.0)*cj2);
IkReal x257=(cj1*r00);
evalcond[0]=((IKsin(j5))+((cj2*r02))+((sj2*x257))+((sj2*x255)));
evalcond[1]=((((-1.0)*x255*x256))+(((-1.0)*x256*x257))+(((-1.0)*(IKcos(j5))))+((r02*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x258=(cj1*r00);
IkReal x259=((1.0)*sj2);
IkReal x260=(r01*sj1);
if( IKabs(((((-1.0)*x259*x260))+(((-1.0)*cj2*r02))+(((-1.0)*x258*x259)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*x258))+(((-1.0)*r02*x259))+((cj2*x260)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x259*x260))+(((-1.0)*cj2*r02))+(((-1.0)*x258*x259))))+IKsqr((((cj2*x258))+(((-1.0)*r02*x259))+((cj2*x260))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x259*x260))+(((-1.0)*cj2*r02))+(((-1.0)*x258*x259))), (((cj2*x258))+(((-1.0)*r02*x259))+((cj2*x260))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x261=(r01*sj1);
IkReal x262=((1.0)*cj2);
IkReal x263=(cj1*r00);
evalcond[0]=(((sj2*x263))+((sj2*x261))+(IKsin(j5))+((cj2*r02)));
evalcond[1]=((((-1.0)*x262*x263))+((r02*sj2))+(((-1.0)*x261*x262))+(IKcos(j5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x264=((1.0)*sj2);
IkReal x265=(cj1*r00);
IkReal x266=((1.0)*cj2);
IkReal x267=(r01*sj1);
CheckValue<IkReal> x268=IKPowWithIntegerCheck(cj4,-1);
if(!x268.valid){
continue;
}
if( IKabs(((((-1.0)*r02*x266))+(((-1.0)*x264*x265))+(((-1.0)*x264*x267)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x268.value)*((((r02*sj2))+(((-1.0)*x265*x266))+(((-1.0)*x266*x267)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*x266))+(((-1.0)*x264*x265))+(((-1.0)*x264*x267))))+IKsqr(((x268.value)*((((r02*sj2))+(((-1.0)*x265*x266))+(((-1.0)*x266*x267))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r02*x266))+(((-1.0)*x264*x265))+(((-1.0)*x264*x267))), ((x268.value)*((((r02*sj2))+(((-1.0)*x265*x266))+(((-1.0)*x266*x267))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x269=IKcos(j5);
IkReal x270=(r01*sj1);
IkReal x271=((1.0)*cj2);
IkReal x272=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((sj4*x269)));
evalcond[1]=(((sj2*x272))+((sj2*x270))+(IKsin(j5))+((cj2*r02)));
evalcond[2]=((((-1.0)*cj4*x269))+(((-1.0)*x271*x272))+((r02*sj2))+(((-1.0)*x270*x271)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x273=((1.0)*cj1);
CheckValue<IkReal> x274=IKPowWithIntegerCheck(sj4,-1);
if(!x274.valid){
continue;
}
if( IKabs(((((-1.0)*r00*sj2*x273))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x274.value)*((((r00*sj1))+(((-1.0)*r01*x273)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*sj2*x273))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))+IKsqr(((x274.value)*((((r00*sj1))+(((-1.0)*r01*x273))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r00*sj2*x273))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))), ((x274.value)*((((r00*sj1))+(((-1.0)*r01*x273))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x275=IKcos(j5);
IkReal x276=(r01*sj1);
IkReal x277=((1.0)*cj2);
IkReal x278=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((sj4*x275)));
evalcond[1]=(((sj2*x276))+((sj2*x278))+(IKsin(j5))+((cj2*r02)));
evalcond[2]=((((-1.0)*cj4*x275))+(((-1.0)*x277*x278))+((r02*sj2))+(((-1.0)*x276*x277)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x279=(cj2*pz);
IkReal x280=(cj1*px);
IkReal x281=((3.27532602861291)*cj2);
IkReal x282=((0.14079334200108)*sj2);
IkReal x283=(py*sj1);
IkReal x284=((3.27532602861291)*sj2);
IkReal x285=((0.14079334200108)*cj2);
if( IKabs(((0.0690323835165496)+(((-0.14079334200108)*x279))+(((-1.0)*x280*x282))+(((-1.0)*x282*x283))+(((-1.0)*pz*x284))+((x280*x281))+((x281*x283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.6059251050892)+(((3.27532602861291)*x279))+(((-1.0)*pz*x282))+((x280*x284))+((x280*x285))+((x283*x284))+((x283*x285)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0690323835165496)+(((-0.14079334200108)*x279))+(((-1.0)*x280*x282))+(((-1.0)*x282*x283))+(((-1.0)*pz*x284))+((x280*x281))+((x281*x283))))+IKsqr(((-1.6059251050892)+(((3.27532602861291)*x279))+(((-1.0)*pz*x282))+((x280*x284))+((x280*x285))+((x283*x284))+((x283*x285))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((0.0690323835165496)+(((-0.14079334200108)*x279))+(((-1.0)*x280*x282))+(((-1.0)*x282*x283))+(((-1.0)*pz*x284))+((x280*x281))+((x281*x283))), ((-1.6059251050892)+(((3.27532602861291)*x279))+(((-1.0)*pz*x282))+((x280*x284))+((x280*x285))+((x283*x284))+((x283*x285))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x286=IKcos(j4);
IkReal x287=IKsin(j4);
IkReal x288=(py*sj1);
IkReal x289=(cj1*px);
IkReal x290=((1.0)*cj2);
evalcond[0]=((-0.49031)+(((-0.30475)*x286))+((sj2*x288))+((sj2*x289))+(((0.0131)*x287))+((cj2*pz)));
evalcond[1]=((((-1.0)*x289*x290))+(((0.0131)*x286))+(((0.30475)*x287))+(((-1.0)*x288*x290))+((pz*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x291=((1.0)*r01);
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x291)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*sj2*x291))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x291))))+IKsqr(((((-1.0)*sj1*sj2*x291))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x291))), ((((-1.0)*sj1*sj2*x291))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x292=((1.0)*cj1);
if( IKabs((((r00*sj1))+(((-1.0)*r01*x292)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj2*r00*x292))+((r02*sj2))+(((-1.0)*cj2*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*r01*x292))))+IKsqr(((((-1.0)*cj2*r00*x292))+((r02*sj2))+(((-1.0)*cj2*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*r01*x292))), ((((-1.0)*cj2*r00*x292))+((r02*sj2))+(((-1.0)*cj2*r01*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x293=((1.0)*sj1);
evalcond[0]=((((-1.0)*r00*x293))+((cj1*r01))+(IKsin(j5)));
evalcond[1]=((((-1.0)*cj2*r01*x293))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x294=((1.0)*cj2);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*r01*sj1*x294))+((r02*sj2))+(IKcos(j5))+(((-1.0)*cj1*r00*x294)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x295=((1.0)*r01);
CheckValue<IkReal> x296=IKPowWithIntegerCheck(cj4,-1);
if(!x296.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x295)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x296.value)*((((r02*sj2))+(((-1.0)*cj2*sj1*x295))+(((-1.0)*cj1*cj2*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x295))))+IKsqr(((x296.value)*((((r02*sj2))+(((-1.0)*cj2*sj1*x295))+(((-1.0)*cj1*cj2*r00))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x295))), ((x296.value)*((((r02*sj2))+(((-1.0)*cj2*sj1*x295))+(((-1.0)*cj1*cj2*r00))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x297=IKcos(j5);
IkReal x298=(r01*sj1);
IkReal x299=((1.0)*cj2);
IkReal x300=(cj1*r00);
IkReal x301=((1.0)*x297);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=(((sj2*x300))+(((-1.0)*sj4*x301))+((cj2*r02))+((sj2*x298)));
evalcond[2]=((((-1.0)*cj4*x301))+((r02*sj2))+(((-1.0)*x298*x299))+(((-1.0)*x299*x300)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x302=IKPowWithIntegerCheck(sj4,-1);
if(!x302.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x302.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr(((x302.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), ((x302.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x303=IKcos(j5);
IkReal x304=(r01*sj1);
IkReal x305=((1.0)*cj2);
IkReal x306=(cj1*r00);
IkReal x307=((1.0)*x303);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=(((sj2*x304))+((sj2*x306))+(((-1.0)*sj4*x307))+((cj2*r02)));
evalcond[2]=((((-1.0)*cj4*x307))+((r02*sj2))+(((-1.0)*x305*x306))+(((-1.0)*x304*x305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x308=(cj2*pz);
IkReal x309=(cj1*px);
IkReal x310=((3.27532602861291)*cj2);
IkReal x311=((0.14079334200108)*sj2);
IkReal x312=(py*sj1);
IkReal x313=((3.27532602861291)*sj2);
IkReal x314=((0.14079334200108)*cj2);
if( IKabs(((-0.0059569663000657)+((x310*x312))+((x309*x311))+((x309*x310))+((x311*x312))+(((-1.0)*pz*x313))+(((0.14079334200108)*x308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.138579044270612)+((x312*x314))+(((-1.0)*x312*x313))+((x309*x314))+(((-3.27532602861291)*x308))+(((-1.0)*pz*x311))+(((-1.0)*x309*x313)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.0059569663000657)+((x310*x312))+((x309*x311))+((x309*x310))+((x311*x312))+(((-1.0)*pz*x313))+(((0.14079334200108)*x308))))+IKsqr(((0.138579044270612)+((x312*x314))+(((-1.0)*x312*x313))+((x309*x314))+(((-3.27532602861291)*x308))+(((-1.0)*pz*x311))+(((-1.0)*x309*x313))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-0.0059569663000657)+((x310*x312))+((x309*x311))+((x309*x310))+((x311*x312))+(((-1.0)*pz*x313))+(((0.14079334200108)*x308))), ((0.138579044270612)+((x312*x314))+(((-1.0)*x312*x313))+((x309*x314))+(((-3.27532602861291)*x308))+(((-1.0)*pz*x311))+(((-1.0)*x309*x313))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x315=IKcos(j4);
IkReal x316=IKsin(j4);
IkReal x317=(py*sj1);
IkReal x318=(cj1*px);
IkReal x319=((1.0)*cj2);
evalcond[0]=((-0.04231)+(((0.30475)*x315))+((cj2*pz))+((sj2*x318))+((sj2*x317))+(((-0.0131)*x316)));
evalcond[1]=((((-1.0)*x318*x319))+(((0.0131)*x315))+(((0.30475)*x316))+((pz*sj2))+(((-1.0)*x317*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x320=((1.0)*cj2);
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r00*x320))+(((-1.0)*r01*sj1*x320))+((r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr(((((-1.0)*cj1*r00*x320))+(((-1.0)*r01*sj1*x320))+((r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), ((((-1.0)*cj1*r00*x320))+(((-1.0)*r01*sj1*x320))+((r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x321=((1.0)*sj1);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*x321))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x321))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x322=((1.0)*sj1);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*x322))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x322))+((r02*sj2))+(IKcos(j5))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x323=((1.0)*sj1);
if( IKabs((((cj1*r01))+(((-1.0)*r00*x323)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r01*sj2*x323))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*x323))))+IKsqr(((((-1.0)*r01*sj2*x323))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*x323))), ((((-1.0)*r01*sj2*x323))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x324=((1.0)*r00);
CheckValue<IkReal> x325=IKPowWithIntegerCheck(sj4,-1);
if(!x325.valid){
continue;
}
if( IKabs(((((-1.0)*sj1*x324))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x325.value)*(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*cj1*sj2*x324)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*x324))+((cj1*r01))))+IKsqr(((x325.value)*(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*cj1*sj2*x324))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj1*x324))+((cj1*r01))), ((x325.value)*(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*cj1*sj2*x324))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x326=IKcos(j5);
IkReal x327=(r01*sj1);
IkReal x328=((1.0)*cj2);
IkReal x329=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj4*x326))+((sj2*x327))+((sj2*x329))+((cj2*r02)));
evalcond[2]=((((-1.0)*x327*x328))+((r02*sj2))+(((-1.0)*x328*x329))+(((-1.0)*cj4*x326)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x330=((1.0)*sj1);
CheckValue<IkReal> x331=IKPowWithIntegerCheck(cj4,-1);
if(!x331.valid){
continue;
}
if( IKabs(((((-1.0)*r00*x330))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x331.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x330)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*x330))+((cj1*r01))))+IKsqr(((x331.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x330))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r00*x330))+((cj1*r01))), ((x331.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x330))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x332=IKcos(j5);
IkReal x333=(r01*sj1);
IkReal x334=((1.0)*cj2);
IkReal x335=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj2*x333))+((sj2*x335))+((cj2*r02))+((sj4*x332)));
evalcond[2]=((((-1.0)*x333*x334))+((r02*sj2))+(((-1.0)*cj4*x332))+(((-1.0)*x334*x335)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x336=((5240000.0)*cj3);
IkReal x337=(py*sj1);
IkReal x338=(pz*sj2);
IkReal x339=((5240000.0)*sj2);
IkReal x340=((121900000.0)*sj2);
IkReal x341=((121900000.0)*cj3);
IkReal x342=(cj1*px);
IkReal x343=(cj2*pz);
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x344.valid){
continue;
}
CheckValue<IkReal> x345 = IKatan2WithCheck(IkReal(((1395464.4)+(((-1.0)*x337*x339))+(((1173760.0)*cj3))+(((-5240000.0)*x343))+((cj2*x341*x342))+(((-1.0)*x338*x341))+((cj2*x337*x341))+(((-1.0)*x339*x342)))),IkReal(((-32463189.0)+(((-27305600.0)*cj3))+((cj2*x336*x337))+((x337*x340))+(((121900000.0)*x343))+((x340*x342))+((cj2*x336*x342))+(((-1.0)*x336*x338)))),IKFAST_ATAN2_MAGTHRESH);
if(!x345.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x344.value)))+(x345.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x346=IKcos(j4);
IkReal x347=IKsin(j4);
IkReal x348=(py*sj1);
IkReal x349=((1.0)*px);
IkReal x350=((0.0131)*x347);
IkReal x351=((0.30475)*x346);
evalcond[0]=((0.00025)+(((-0.224)*sj3))+((cj1*py))+((sj3*x350))+(((-1.0)*sj1*x349))+(((-1.0)*sj3*x351)));
evalcond[1]=((((-1.0)*cj2*x348))+(((0.0131)*x346))+(((0.30475)*x347))+((pz*sj2))+(((-1.0)*cj1*cj2*x349)));
evalcond[2]=((-0.26631)+((cj3*x350))+((sj2*x348))+(((-1.0)*cj3*x351))+(((-0.224)*cj3))+((cj2*pz))+((cj1*px*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj3;
j5eval[1]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x352=(cj2*r02);
IkReal x353=(cj1*r01);
IkReal x354=(sj1*sj3);
IkReal x355=(r01*sj2);
IkReal x356=(cj3*sj1);
IkReal x357=(cj1*r00*sj2);
if( IKabs((((r00*x356))+(((-1.0)*cj3*x353))+((x354*x355))+((sj3*x352))+((sj3*x357)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*x352))+((cj3*x357))+((x355*x356))+((sj3*x353))+(((-1.0)*r00*x354)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*x356))+(((-1.0)*cj3*x353))+((x354*x355))+((sj3*x352))+((sj3*x357))))+IKsqr((((cj3*x352))+((cj3*x357))+((x355*x356))+((sj3*x353))+(((-1.0)*r00*x354))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*x356))+(((-1.0)*cj3*x353))+((x354*x355))+((sj3*x352))+((sj3*x357))), (((cj3*x352))+((cj3*x357))+((x355*x356))+((sj3*x353))+(((-1.0)*r00*x354))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x358=IKcos(j5);
IkReal x359=IKsin(j5);
IkReal x360=((1.0)*x358);
evalcond[0]=(((cj3*x359))+((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj3*x360)));
evalcond[1]=((((-1.0)*sj3*x359))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))+(((-1.0)*cj3*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x361=(cj2*r02);
IkReal x362=((1.0)*cj3);
IkReal x363=(cj1*r01);
IkReal x364=(r00*sj1);
IkReal x365=(cj1*r00*sj2);
IkReal x366=(r01*sj1*sj2);
if( IKabs(((((-1.0)*x362*x363))+((sj3*x366))+((sj3*x365))+((sj3*x361))+((cj3*x364)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x363))+(((-1.0)*x362*x365))+(((-1.0)*x362*x366))+(((-1.0)*x361*x362))+((sj3*x364)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x362*x363))+((sj3*x366))+((sj3*x365))+((sj3*x361))+((cj3*x364))))+IKsqr(((((-1.0)*sj3*x363))+(((-1.0)*x362*x365))+(((-1.0)*x362*x366))+(((-1.0)*x361*x362))+((sj3*x364))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x362*x363))+((sj3*x366))+((sj3*x365))+((sj3*x361))+((cj3*x364))), ((((-1.0)*sj3*x363))+(((-1.0)*x362*x365))+(((-1.0)*x362*x366))+(((-1.0)*x361*x362))+((sj3*x364))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x367=IKcos(j5);
IkReal x368=IKsin(j5);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((sj3*x367))+((cj3*x368)));
evalcond[1]=((((-1.0)*sj3*x368))+((cj2*r02))+((cj1*r00*sj2))+((cj3*x367))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x369=((1.0)*r01);
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x369)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r00*sj2))+(((-1.0)*sj1*sj2*x369))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x369))))+IKsqr(((((-1.0)*cj1*r00*sj2))+(((-1.0)*sj1*sj2*x369))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x369))), ((((-1.0)*cj1*r00*sj2))+(((-1.0)*sj1*sj2*x369))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x370=((1.0)*cj1);
if( IKabs((((r00*sj1))+(((-1.0)*r01*x370)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x370)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*r01*x370))))+IKsqr((((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x370))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*r01*x370))), (((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x370))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x371=((1.0)*sj1);
evalcond[0]=((((-1.0)*r00*x371))+((cj1*r01))+(IKsin(j5)));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x372=((1.0)*cj2);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=(((r02*sj2))+(IKcos(j5))+(((-1.0)*cj1*r00*x372))+(((-1.0)*r01*sj1*x372)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x373=((1.0)*r01);
CheckValue<IkReal> x374=IKPowWithIntegerCheck(cj4,-1);
if(!x374.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x373)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x374.value)*(((((-1.0)*cj2*sj1*x373))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x373))))+IKsqr(((x374.value)*(((((-1.0)*cj2*sj1*x373))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x373))), ((x374.value)*(((((-1.0)*cj2*sj1*x373))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x375=IKcos(j5);
IkReal x376=(r01*sj1);
IkReal x377=((1.0)*cj2);
IkReal x378=(cj1*r00);
IkReal x379=((1.0)*x375);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*sj4*x379))+((cj2*r02))+((sj2*x378))+((sj2*x376)));
evalcond[2]=((((-1.0)*cj4*x379))+(((-1.0)*x377*x378))+((r02*sj2))+(((-1.0)*x376*x377)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x380=IKPowWithIntegerCheck(sj4,-1);
if(!x380.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x380.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr(((x380.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), ((x380.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x381=IKcos(j5);
IkReal x382=(r01*sj1);
IkReal x383=((1.0)*cj2);
IkReal x384=(cj1*r00);
IkReal x385=((1.0)*x381);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*sj4*x385))+((cj2*r02))+((sj2*x382))+((sj2*x384)));
evalcond[2]=(((r02*sj2))+(((-1.0)*cj4*x385))+(((-1.0)*x382*x383))+(((-1.0)*x383*x384)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x386=((1.0)*cj2);
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r00*x386))+((r02*sj2))+(((-1.0)*r01*sj1*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr(((((-1.0)*cj1*r00*x386))+((r02*sj2))+(((-1.0)*r01*sj1*x386))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), ((((-1.0)*cj1*r00*x386))+((r02*sj2))+(((-1.0)*r01*sj1*x386))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x387=((1.0)*sj1);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*x387))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x387))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x388=((1.0)*sj1);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*x388))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x388))+((r02*sj2))+(IKcos(j5))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x389=((1.0)*sj1);
if( IKabs((((cj1*r01))+(((-1.0)*r00*x389)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x389))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*x389))))+IKsqr(((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x389))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*x389))), ((((-1.0)*cj1*r00*sj2))+(((-1.0)*r01*sj2*x389))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x390=((1.0)*r00);
CheckValue<IkReal> x391=IKPowWithIntegerCheck(sj4,-1);
if(!x391.valid){
continue;
}
if( IKabs(((((-1.0)*sj1*x390))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x391.value)*(((((-1.0)*cj1*sj2*x390))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*x390))+((cj1*r01))))+IKsqr(((x391.value)*(((((-1.0)*cj1*sj2*x390))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj1*x390))+((cj1*r01))), ((x391.value)*(((((-1.0)*cj1*sj2*x390))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x392=IKcos(j5);
IkReal x393=(r01*sj1);
IkReal x394=((1.0)*cj2);
IkReal x395=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj2*x395))+((sj2*x393))+((cj2*r02))+((sj4*x392)));
evalcond[2]=((((-1.0)*x394*x395))+((r02*sj2))+(((-1.0)*cj4*x392))+(((-1.0)*x393*x394)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x396=((1.0)*sj1);
CheckValue<IkReal> x397=IKPowWithIntegerCheck(cj4,-1);
if(!x397.valid){
continue;
}
if( IKabs((((cj1*r01))+(((-1.0)*r00*x396)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x397.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x396)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*x396))))+IKsqr(((x397.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x396))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*x396))), ((x397.value)*((((r02*sj2))+(((-1.0)*cj1*cj2*r00))+(((-1.0)*cj2*r01*x396))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x398=IKcos(j5);
IkReal x399=(r01*sj1);
IkReal x400=((1.0)*cj2);
IkReal x401=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj2*x401))+((sj2*x399))+((cj2*r02))+((sj4*x398)));
evalcond[2]=(((r02*sj2))+(((-1.0)*cj4*x398))+(((-1.0)*x400*x401))+(((-1.0)*x399*x400)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((cj1*r01))+(((-1.0)*r00*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((r00*sj1))+(((-1.0)*cj1*r01))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x402=(r01*sj1);
IkReal x403=((1.0)*cj2);
IkReal x404=(cj1*r00);
if( IKabs((((sj2*x404))+((sj2*x402))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x403*x404))+(((-1.0)*x402*x403))+((r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x404))+((sj2*x402))+((cj2*r02))))+IKsqr(((((-1.0)*x403*x404))+(((-1.0)*x402*x403))+((r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x404))+((sj2*x402))+((cj2*r02))), ((((-1.0)*x403*x404))+(((-1.0)*x402*x403))+((r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x405=(r01*sj1);
IkReal x406=((1.0)*cj2);
IkReal x407=(cj1*r00);
evalcond[0]=(((sj2*x405))+((sj2*x407))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*x406*x407))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*x405*x406)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x408=(cj1*r00);
IkReal x409=(r01*sj1);
if( IKabs((((sj2*x409))+((sj2*x408))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*sj2))+((cj2*x409))+((cj2*x408)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x409))+((sj2*x408))+((cj2*r02))))+IKsqr(((((-1.0)*r02*sj2))+((cj2*x409))+((cj2*x408))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x409))+((sj2*x408))+((cj2*r02))), ((((-1.0)*r02*sj2))+((cj2*x409))+((cj2*x408))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x410=(r01*sj1);
IkReal x411=((1.0)*cj2);
IkReal x412=(cj1*r00);
evalcond[0]=(((r02*sj2))+(IKcos(j5))+(((-1.0)*x411*x412))+(((-1.0)*x410*x411)));
evalcond[1]=(((sj2*x412))+((sj2*x410))+((cj2*r02))+(((-1.0)*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x413=(r01*sj1);
IkReal x414=((1.0)*cj2);
IkReal x415=(cj1*r00);
CheckValue<IkReal> x416=IKPowWithIntegerCheck(cj4,-1);
if(!x416.valid){
continue;
}
if( IKabs((((sj2*x415))+((sj2*x413))+((cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x416.value)*((((r02*sj2))+(((-1.0)*x413*x414))+(((-1.0)*x414*x415)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj2*x415))+((sj2*x413))+((cj2*r02))))+IKsqr(((x416.value)*((((r02*sj2))+(((-1.0)*x413*x414))+(((-1.0)*x414*x415))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj2*x415))+((sj2*x413))+((cj2*r02))), ((x416.value)*((((r02*sj2))+(((-1.0)*x413*x414))+(((-1.0)*x414*x415))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x417=IKcos(j5);
IkReal x418=(r01*sj1);
IkReal x419=((1.0)*cj2);
IkReal x420=(cj1*r00);
IkReal x421=((1.0)*x417);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj4*x421)));
evalcond[1]=(((sj2*x418))+((cj2*r02))+((sj2*x420))+(((-1.0)*(IKsin(j5)))));
evalcond[2]=((((-1.0)*x418*x419))+((r02*sj2))+(((-1.0)*cj4*x421))+(((-1.0)*x419*x420)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x422=IKPowWithIntegerCheck(sj4,-1);
if(!x422.valid){
continue;
}
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x422.value)*((((cj1*r01))+(((-1.0)*r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr(((x422.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), ((x422.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x423=IKcos(j5);
IkReal x424=(r01*sj1);
IkReal x425=((1.0)*cj2);
IkReal x426=(cj1*r00);
IkReal x427=((1.0)*x423);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj4*x427)));
evalcond[1]=(((cj2*r02))+((sj2*x426))+((sj2*x424))+(((-1.0)*(IKsin(j5)))));
evalcond[2]=(((r02*sj2))+(((-1.0)*x425*x426))+(((-1.0)*cj4*x427))+(((-1.0)*x424*x425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x428=((1.0)*r01);
if( IKabs(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*sj1*sj2*x428)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*x428)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*sj1*sj2*x428))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*x428))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*sj1*sj2*x428))), (((r00*sj1))+(((-1.0)*cj1*x428))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x429=((1.0)*sj1);
if( IKabs(((((-1.0)*r01*sj2*x429))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01))+(((-1.0)*r00*x429)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj2*x429))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))+IKsqr((((cj1*r01))+(((-1.0)*r00*x429))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r01*sj2*x429))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))), (((cj1*r01))+(((-1.0)*r00*x429))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x430=((1.0)*sj2);
IkReal x431=(cj1*r00);
IkReal x432=((1.0)*cj2);
IkReal x433=(r01*sj1);
if( IKabs(((((-1.0)*x430*x431))+(((-1.0)*x430*x433))+(((-1.0)*r02*x432)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x431*x432))+(((-1.0)*x432*x433))+((r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x430*x431))+(((-1.0)*x430*x433))+(((-1.0)*r02*x432))))+IKsqr(((((-1.0)*x431*x432))+(((-1.0)*x432*x433))+((r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x430*x431))+(((-1.0)*x430*x433))+(((-1.0)*r02*x432))), ((((-1.0)*x431*x432))+(((-1.0)*x432*x433))+((r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x434=(r01*sj1);
IkReal x435=((1.0)*cj2);
IkReal x436=(cj1*r00);
evalcond[0]=((IKsin(j5))+((cj2*r02))+((sj2*x434))+((sj2*x436)));
evalcond[1]=((((-1.0)*x435*x436))+(((-1.0)*x434*x435))+(((-1.0)*(IKcos(j5))))+((r02*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x437=(cj1*r00);
IkReal x438=((1.0)*sj2);
IkReal x439=(r01*sj1);
if( IKabs(((((-1.0)*x437*x438))+(((-1.0)*x438*x439))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*x438))+((cj2*x437))+((cj2*x439)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x437*x438))+(((-1.0)*x438*x439))+(((-1.0)*cj2*r02))))+IKsqr(((((-1.0)*r02*x438))+((cj2*x437))+((cj2*x439))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x437*x438))+(((-1.0)*x438*x439))+(((-1.0)*cj2*r02))), ((((-1.0)*r02*x438))+((cj2*x437))+((cj2*x439))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x440=(r01*sj1);
IkReal x441=((1.0)*cj2);
IkReal x442=(cj1*r00);
evalcond[0]=((IKsin(j5))+((cj2*r02))+((sj2*x440))+((sj2*x442)));
evalcond[1]=(((r02*sj2))+(IKcos(j5))+(((-1.0)*x440*x441))+(((-1.0)*x441*x442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x443=((1.0)*sj2);
IkReal x444=(cj1*r00);
IkReal x445=((1.0)*cj2);
IkReal x446=(r01*sj1);
CheckValue<IkReal> x447=IKPowWithIntegerCheck(cj4,-1);
if(!x447.valid){
continue;
}
if( IKabs(((((-1.0)*x443*x446))+(((-1.0)*x443*x444))+(((-1.0)*r02*x445)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x447.value)*(((((-1.0)*x444*x445))+(((-1.0)*x445*x446))+((r02*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x443*x446))+(((-1.0)*x443*x444))+(((-1.0)*r02*x445))))+IKsqr(((x447.value)*(((((-1.0)*x444*x445))+(((-1.0)*x445*x446))+((r02*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x443*x446))+(((-1.0)*x443*x444))+(((-1.0)*r02*x445))), ((x447.value)*(((((-1.0)*x444*x445))+(((-1.0)*x445*x446))+((r02*sj2))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x448=IKcos(j5);
IkReal x449=(r01*sj1);
IkReal x450=((1.0)*cj2);
IkReal x451=(cj1*r00);
evalcond[0]=(((sj4*x448))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((sj2*x451))+(IKsin(j5))+((cj2*r02))+((sj2*x449)));
evalcond[2]=((((-1.0)*cj4*x448))+((r02*sj2))+(((-1.0)*x450*x451))+(((-1.0)*x449*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x452=((1.0)*cj1);
CheckValue<IkReal> x453=IKPowWithIntegerCheck(sj4,-1);
if(!x453.valid){
continue;
}
if( IKabs(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r00*sj2*x452)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x453.value)*((((r00*sj1))+(((-1.0)*r01*x452)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r00*sj2*x452))))+IKsqr(((x453.value)*((((r00*sj1))+(((-1.0)*r01*x452))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r00*sj2*x452))), ((x453.value)*((((r00*sj1))+(((-1.0)*r01*x452))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x454=IKcos(j5);
IkReal x455=(r01*sj1);
IkReal x456=((1.0)*cj2);
IkReal x457=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((sj4*x454)));
evalcond[1]=(((sj2*x455))+((sj2*x457))+(IKsin(j5))+((cj2*r02)));
evalcond[2]=((((-1.0)*cj4*x454))+(((-1.0)*x456*x457))+((r02*sj2))+(((-1.0)*x455*x456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=cj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x458=(r01*sj1);
IkReal x459=((1.0)*cj2);
IkReal x460=(cj1*r00);
CheckValue<IkReal> x461=IKPowWithIntegerCheck(sj3,-1);
if(!x461.valid){
continue;
}
if( IKabs(((x461.value)*((((sj2*x458))+((cj2*r02))+((sj2*x460)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x459*x460))+((r02*sj2))+(((-1.0)*x458*x459)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x461.value)*((((sj2*x458))+((cj2*r02))+((sj2*x460))))))+IKsqr(((((-1.0)*x459*x460))+((r02*sj2))+(((-1.0)*x458*x459))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x461.value)*((((sj2*x458))+((cj2*r02))+((sj2*x460))))), ((((-1.0)*x459*x460))+((r02*sj2))+(((-1.0)*x458*x459))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x462=IKsin(j5);
IkReal x463=(r01*sj1);
IkReal x464=((1.0)*cj2);
IkReal x465=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x462)));
evalcond[1]=((((-1.0)*sj3*x462))+((cj2*r02))+((sj2*x465))+((sj2*x463)));
evalcond[2]=((((-1.0)*x463*x464))+(((-1.0)*x464*x465))+(((-1.0)*(IKcos(j5))))+((r02*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x466=((1.0)*r01);
CheckValue<IkReal> x467=IKPowWithIntegerCheck(cj3,-1);
if(!x467.valid){
continue;
}
if( IKabs(((x467.value)*((((r00*sj1))+(((-1.0)*cj1*x466)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj2))+(((-1.0)*cj2*sj1*x466))+(((-1.0)*cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x467.value)*((((r00*sj1))+(((-1.0)*cj1*x466))))))+IKsqr((((r02*sj2))+(((-1.0)*cj2*sj1*x466))+(((-1.0)*cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x467.value)*((((r00*sj1))+(((-1.0)*cj1*x466))))), (((r02*sj2))+(((-1.0)*cj2*sj1*x466))+(((-1.0)*cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x468=IKsin(j5);
IkReal x469=(r01*sj1);
IkReal x470=((1.0)*cj2);
IkReal x471=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x468)));
evalcond[1]=((((-1.0)*sj3*x468))+((cj2*r02))+((sj2*x471))+((sj2*x469)));
evalcond[2]=((((-1.0)*x469*x470))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*x470*x471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=cj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x472=(r01*sj1);
IkReal x473=(cj1*r00);
CheckValue<IkReal> x474=IKPowWithIntegerCheck(sj3,-1);
if(!x474.valid){
continue;
}
if( IKabs(((x474.value)*((((cj2*r02))+((sj2*x473))+((sj2*x472)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*x472))+((cj2*x473))+(((-1.0)*r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x474.value)*((((cj2*r02))+((sj2*x473))+((sj2*x472))))))+IKsqr((((cj2*x472))+((cj2*x473))+(((-1.0)*r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x474.value)*((((cj2*r02))+((sj2*x473))+((sj2*x472))))), (((cj2*x472))+((cj2*x473))+(((-1.0)*r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x475=IKsin(j5);
IkReal x476=(r01*sj1);
IkReal x477=((1.0)*cj2);
IkReal x478=(cj1*r00);
evalcond[0]=(((cj3*x475))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=((((-1.0)*x477*x478))+(((-1.0)*x476*x477))+((r02*sj2))+(IKcos(j5)));
evalcond[2]=(((cj2*r02))+(((-1.0)*sj3*x475))+((sj2*x478))+((sj2*x476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x479=IKPowWithIntegerCheck(cj3,-1);
if(!x479.valid){
continue;
}
if( IKabs(((x479.value)*((((r00*sj1))+(((-1.0)*cj1*r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x479.value)*((((r00*sj1))+(((-1.0)*cj1*r01))))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x479.value)*((((r00*sj1))+(((-1.0)*cj1*r01))))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x480=IKsin(j5);
IkReal x481=(r01*sj1);
IkReal x482=((1.0)*cj2);
IkReal x483=(cj1*r00);
evalcond[0]=(((cj3*x480))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((r02*sj2))+(((-1.0)*x481*x482))+(IKcos(j5))+(((-1.0)*x482*x483)));
evalcond[2]=((((-1.0)*sj3*x480))+((cj2*r02))+((sj2*x481))+((sj2*x483)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x491=IKPowWithIntegerCheck(cj4,-1);
if(!x491.valid){
continue;
}
IkReal x484=x491.value;
IkReal x485=(cj4*sj2);
IkReal x486=(cj1*r00);
IkReal x487=(r01*sj1);
IkReal x488=(cj3*sj4);
IkReal x489=(r02*sj2);
IkReal x490=((1.0)*cj2);
CheckValue<IkReal> x492=IKPowWithIntegerCheck(sj3,-1);
if(!x492.valid){
continue;
}
if( IKabs((x484*(x492.value)*((((x485*x486))+((x485*x487))+((cj2*x487*x488))+(((-1.0)*x488*x489))+((cj2*x486*x488))+((cj2*cj4*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x484*(((((-1.0)*x486*x490))+x489+(((-1.0)*x487*x490)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x484*(x492.value)*((((x485*x486))+((x485*x487))+((cj2*x487*x488))+(((-1.0)*x488*x489))+((cj2*x486*x488))+((cj2*cj4*r02))))))+IKsqr((x484*(((((-1.0)*x486*x490))+x489+(((-1.0)*x487*x490))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x484*(x492.value)*((((x485*x486))+((x485*x487))+((cj2*x487*x488))+(((-1.0)*x488*x489))+((cj2*x486*x488))+((cj2*cj4*r02))))), (x484*(((((-1.0)*x486*x490))+x489+(((-1.0)*x487*x490))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x493=IKcos(j5);
IkReal x494=IKsin(j5);
IkReal x495=(r01*sj1);
IkReal x496=((1.0)*cj2);
IkReal x497=(cj1*r00);
IkReal x498=((1.0)*x493);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x494))+(((-1.0)*sj3*sj4*x498)));
evalcond[1]=((((-1.0)*x495*x496))+(((-1.0)*x496*x497))+((r02*sj2))+(((-1.0)*cj4*x498)));
evalcond[2]=((((-1.0)*sj3*x494))+(((-1.0)*cj3*sj4*x498))+((cj2*r02))+((sj2*x497))+((sj2*x495)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x505=IKPowWithIntegerCheck(cj4,-1);
if(!x505.valid){
continue;
}
IkReal x499=x505.value;
IkReal x500=((1.0)*r01);
IkReal x501=(cj2*sj1);
IkReal x502=(r02*sj2);
IkReal x503=(sj3*sj4);
IkReal x504=((1.0)*cj1*cj2*r00);
CheckValue<IkReal> x506=IKPowWithIntegerCheck(cj3,-1);
if(!x506.valid){
continue;
}
if( IKabs((x499*(x506.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x500))+(((-1.0)*x503*x504))+((x502*x503))+(((-1.0)*x500*x501*x503)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x499*(((((-1.0)*x504))+x502+(((-1.0)*x500*x501)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x499*(x506.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x500))+(((-1.0)*x503*x504))+((x502*x503))+(((-1.0)*x500*x501*x503))))))+IKsqr((x499*(((((-1.0)*x504))+x502+(((-1.0)*x500*x501))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x499*(x506.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x500))+(((-1.0)*x503*x504))+((x502*x503))+(((-1.0)*x500*x501*x503))))), (x499*(((((-1.0)*x504))+x502+(((-1.0)*x500*x501))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x507=IKcos(j5);
IkReal x508=IKsin(j5);
IkReal x509=(r01*sj1);
IkReal x510=((1.0)*cj2);
IkReal x511=(cj1*r00);
IkReal x512=((1.0)*x507);
evalcond[0]=((((-1.0)*sj3*sj4*x512))+((cj3*x508))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((r02*sj2))+(((-1.0)*cj4*x512))+(((-1.0)*x509*x510))+(((-1.0)*x510*x511)));
evalcond[2]=((((-1.0)*cj3*sj4*x512))+((sj2*x509))+(((-1.0)*sj3*x508))+((cj2*r02))+((sj2*x511)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x513=(cj2*r02);
IkReal x514=(cj1*r01);
IkReal x515=(sj1*sj3);
IkReal x516=(r01*sj2);
IkReal x517=(cj3*sj1);
IkReal x518=(cj1*r00*sj2);
CheckValue<IkReal> x519=IKPowWithIntegerCheck(sj4,-1);
if(!x519.valid){
continue;
}
if( IKabs(((((-1.0)*cj3*x514))+((sj3*x518))+((sj3*x513))+((x515*x516))+((r00*x517)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x519.value)*((((x516*x517))+((cj3*x518))+((cj3*x513))+((sj3*x514))+(((-1.0)*r00*x515)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x514))+((sj3*x518))+((sj3*x513))+((x515*x516))+((r00*x517))))+IKsqr(((x519.value)*((((x516*x517))+((cj3*x518))+((cj3*x513))+((sj3*x514))+(((-1.0)*r00*x515))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj3*x514))+((sj3*x518))+((sj3*x513))+((x515*x516))+((r00*x517))), ((x519.value)*((((x516*x517))+((cj3*x518))+((cj3*x513))+((sj3*x514))+(((-1.0)*r00*x515))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x520=IKcos(j5);
IkReal x521=IKsin(j5);
IkReal x522=(r01*sj1);
IkReal x523=((1.0)*cj2);
IkReal x524=(cj1*r00);
IkReal x525=((1.0)*x520);
evalcond[0]=((((-1.0)*sj3*sj4*x525))+((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x521)));
evalcond[1]=((((-1.0)*x523*x524))+((r02*sj2))+(((-1.0)*x522*x523))+(((-1.0)*cj4*x525)));
evalcond[2]=((((-1.0)*sj3*x521))+((sj2*x522))+((sj2*x524))+((cj2*r02))+(((-1.0)*cj3*sj4*x525)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x526=(cj1*py);
IkReal x527=((5240000.0)*sj1);
IkReal x528=(cj2*sj3);
IkReal x529=(cj1*px);
IkReal x530=((121900000.0)*sj1);
IkReal x531=(pz*sj2*sj3);
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(((-1310.0)+(((-5240000.0)*x526))+((py*x528*x530))+(((-121900000.0)*x531))+((px*x527))+(((1173760.0)*sj3))+(((121900000.0)*x528*x529)))),IkReal(((30475.0)+((py*x527*x528))+(((121900000.0)*x526))+(((-27305600.0)*sj3))+(((-5240000.0)*x531))+(((-1.0)*px*x530))+(((5240000.0)*x528*x529)))),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
CheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x533.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x532.value)+(((1.5707963267949)*(x533.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x534=IKcos(j4);
IkReal x535=IKsin(j4);
IkReal x536=(py*sj1);
IkReal x537=((1.0)*px);
IkReal x538=((0.0131)*x535);
IkReal x539=((0.30475)*x534);
evalcond[0]=((0.00025)+(((-1.0)*sj1*x537))+(((-0.224)*sj3))+(((-1.0)*sj3*x539))+((sj3*x538))+((cj1*py)));
evalcond[1]=((((0.0131)*x534))+(((0.30475)*x535))+(((-1.0)*cj1*cj2*x537))+(((-1.0)*cj2*x536))+((pz*sj2)));
evalcond[2]=((-0.26631)+((sj2*x536))+(((-1.0)*cj3*x539))+(((-0.224)*cj3))+((cj2*pz))+((cj3*x538))+((cj1*px*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj3;
j5eval[1]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
j5eval[0]=cj4;
j5eval[1]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x540=(cj2*r02);
IkReal x541=(cj1*r01);
IkReal x542=(sj1*sj3);
IkReal x543=(r01*sj2);
IkReal x544=(cj3*sj1);
IkReal x545=(cj1*r00*sj2);
if( IKabs((((x542*x543))+((sj3*x540))+((sj3*x545))+(((-1.0)*cj3*x541))+((r00*x544)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj3*x541))+((x543*x544))+((cj3*x545))+((cj3*x540))+(((-1.0)*r00*x542)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x542*x543))+((sj3*x540))+((sj3*x545))+(((-1.0)*cj3*x541))+((r00*x544))))+IKsqr((((sj3*x541))+((x543*x544))+((cj3*x545))+((cj3*x540))+(((-1.0)*r00*x542))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((x542*x543))+((sj3*x540))+((sj3*x545))+(((-1.0)*cj3*x541))+((r00*x544))), (((sj3*x541))+((x543*x544))+((cj3*x545))+((cj3*x540))+(((-1.0)*r00*x542))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x546=IKcos(j5);
IkReal x547=IKsin(j5);
IkReal x548=((1.0)*x546);
evalcond[0]=((((-1.0)*sj3*x548))+((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x547)));
evalcond[1]=((((-1.0)*cj3*x548))+(((-1.0)*sj3*x547))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x549=(cj2*r02);
IkReal x550=((1.0)*cj3);
IkReal x551=(cj1*r01);
IkReal x552=(r00*sj1);
IkReal x553=(cj1*r00*sj2);
IkReal x554=(r01*sj1*sj2);
if( IKabs((((sj3*x549))+(((-1.0)*x550*x551))+((sj3*x554))+((sj3*x553))+((cj3*x552)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x551))+(((-1.0)*x550*x553))+(((-1.0)*x550*x554))+((sj3*x552))+(((-1.0)*x549*x550)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj3*x549))+(((-1.0)*x550*x551))+((sj3*x554))+((sj3*x553))+((cj3*x552))))+IKsqr(((((-1.0)*sj3*x551))+(((-1.0)*x550*x553))+(((-1.0)*x550*x554))+((sj3*x552))+(((-1.0)*x549*x550))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((sj3*x549))+(((-1.0)*x550*x551))+((sj3*x554))+((sj3*x553))+((cj3*x552))), ((((-1.0)*sj3*x551))+(((-1.0)*x550*x553))+(((-1.0)*x550*x554))+((sj3*x552))+(((-1.0)*x549*x550))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x555=IKcos(j5);
IkReal x556=IKsin(j5);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((sj3*x555))+((cj3*x556)));
evalcond[1]=((((-1.0)*sj3*x556))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))+((cj3*x555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=1.0;
j3=0;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x557=((1.0)*r01);
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x557)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*sj2*x557))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x557))))+IKsqr(((((-1.0)*sj1*sj2*x557))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x557))), ((((-1.0)*sj1*sj2*x557))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x558=((1.0)*cj1);
if( IKabs((((r00*sj1))+(((-1.0)*r01*x558)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x558)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*r01*x558))))+IKsqr((((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x558))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*r01*x558))), (((r02*sj2))+(((-1.0)*cj2*r01*sj1))+(((-1.0)*cj2*r00*x558))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x559=((1.0)*sj1);
evalcond[0]=((((-1.0)*r00*x559))+((cj1*r01))+(IKsin(j5)));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj2*r01*x559))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x560=((1.0)*cj2);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*cj1*r00*x560))+((r02*sj2))+(IKcos(j5))+(((-1.0)*r01*sj1*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x561=((1.0)*r01);
CheckValue<IkReal> x562=IKPowWithIntegerCheck(cj4,-1);
if(!x562.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*x561)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x562.value)*(((((-1.0)*cj2*sj1*x561))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*x561))))+IKsqr(((x562.value)*(((((-1.0)*cj2*sj1*x561))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*x561))), ((x562.value)*(((((-1.0)*cj2*sj1*x561))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x563=IKcos(j5);
IkReal x564=(r01*sj1);
IkReal x565=((1.0)*cj2);
IkReal x566=(cj1*r00);
IkReal x567=((1.0)*x563);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=((((-1.0)*sj4*x567))+((cj2*r02))+((sj2*x564))+((sj2*x566)));
evalcond[2]=((((-1.0)*x564*x565))+(((-1.0)*cj4*x567))+((r02*sj2))+(((-1.0)*x565*x566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x568=IKPowWithIntegerCheck(sj4,-1);
if(!x568.valid){
continue;
}
if( IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x568.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))+IKsqr(((x568.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((r00*sj1))+(((-1.0)*cj1*r01))), ((x568.value)*((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x569=IKcos(j5);
IkReal x570=(r01*sj1);
IkReal x571=((1.0)*cj2);
IkReal x572=(cj1*r00);
IkReal x573=((1.0)*x569);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKsin(j5)));
evalcond[1]=(((cj2*r02))+((sj2*x570))+((sj2*x572))+(((-1.0)*sj4*x573)));
evalcond[2]=((((-1.0)*x570*x571))+(((-1.0)*x571*x572))+((r02*sj2))+(((-1.0)*cj4*x573)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x574=((1.0)*cj2);
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r01*sj1*x574))+((r02*sj2))+(((-1.0)*cj1*r00*x574)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr(((((-1.0)*r01*sj1*x574))+((r02*sj2))+(((-1.0)*cj1*r00*x574))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), ((((-1.0)*r01*sj1*x574))+((r02*sj2))+(((-1.0)*cj1*r00*x574))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x575=((1.0)*sj1);
evalcond[0]=((((-1.0)*r00*x575))+((cj1*r01))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x575))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x576=((1.0)*sj1);
evalcond[0]=((((-1.0)*r00*x576))+((cj1*r01))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*cj2*r01*x576))+((r02*sj2))+(IKcos(j5))+(((-1.0)*cj1*cj2*r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x577=((1.0)*sj1);
if( IKabs(((((-1.0)*r00*x577))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r01*sj2*x577))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*x577))+((cj1*r01))))+IKsqr(((((-1.0)*r01*sj2*x577))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r00*x577))+((cj1*r01))), ((((-1.0)*r01*sj2*x577))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((IKcos(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))+IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*sj1))), (((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x578=((1.0)*r00);
CheckValue<IkReal> x579=IKPowWithIntegerCheck(sj4,-1);
if(!x579.valid){
continue;
}
if( IKabs(((((-1.0)*sj1*x578))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x579.value)*(((((-1.0)*cj1*sj2*x578))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*x578))+((cj1*r01))))+IKsqr(((x579.value)*(((((-1.0)*cj1*sj2*x578))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj1*x578))+((cj1*r01))), ((x579.value)*(((((-1.0)*cj1*sj2*x578))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x580=IKcos(j5);
IkReal x581=(r01*sj1);
IkReal x582=((1.0)*cj2);
IkReal x583=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj2*x581))+((sj2*x583))+((cj2*r02))+((sj4*x580)));
evalcond[2]=((((-1.0)*x582*x583))+((r02*sj2))+(((-1.0)*cj4*x580))+(((-1.0)*x581*x582)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x584=((1.0)*sj1);
CheckValue<IkReal> x585=IKPowWithIntegerCheck(cj4,-1);
if(!x585.valid){
continue;
}
if( IKabs((((cj1*r01))+(((-1.0)*r00*x584)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x585.value)*((((r02*sj2))+(((-1.0)*cj2*r01*x584))+(((-1.0)*cj1*cj2*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r01))+(((-1.0)*r00*x584))))+IKsqr(((x585.value)*((((r02*sj2))+(((-1.0)*cj2*r01*x584))+(((-1.0)*cj1*cj2*r00))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj1*r01))+(((-1.0)*r00*x584))), ((x585.value)*((((r02*sj2))+(((-1.0)*cj2*r01*x584))+(((-1.0)*cj1*cj2*r00))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x586=IKcos(j5);
IkReal x587=(r01*sj1);
IkReal x588=((1.0)*cj2);
IkReal x589=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=(((sj2*x587))+((sj2*x589))+((cj2*r02))+((sj4*x586)));
evalcond[2]=((((-1.0)*x588*x589))+(((-1.0)*x587*x588))+((r02*sj2))+(((-1.0)*cj4*x586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01))+(((-1.0)*r00*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((cj1*r01))+(((-1.0)*r00*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((cj1*r01))+(((-1.0)*r00*sj1))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), (((r00*sj1))+(((-1.0)*cj1*r01))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x590=(r01*sj1);
IkReal x591=((1.0)*cj2);
IkReal x592=(cj1*r00);
if( IKabs((((cj2*r02))+((sj2*x592))+((sj2*x590)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x590*x591))+((r02*sj2))+(((-1.0)*x591*x592)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((sj2*x592))+((sj2*x590))))+IKsqr(((((-1.0)*x590*x591))+((r02*sj2))+(((-1.0)*x591*x592))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((sj2*x592))+((sj2*x590))), ((((-1.0)*x590*x591))+((r02*sj2))+(((-1.0)*x591*x592))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x593=(r01*sj1);
IkReal x594=((1.0)*cj2);
IkReal x595=(cj1*r00);
evalcond[0]=(((cj2*r02))+((sj2*x595))+((sj2*x593))+(((-1.0)*(IKsin(j5)))));
evalcond[1]=((((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*x593*x594))+(((-1.0)*x594*x595)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x596=(cj1*r00);
IkReal x597=(r01*sj1);
if( IKabs((((cj2*r02))+((sj2*x596))+((sj2*x597)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*sj2))+((cj2*x597))+((cj2*x596)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((sj2*x596))+((sj2*x597))))+IKsqr(((((-1.0)*r02*sj2))+((cj2*x597))+((cj2*x596))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((sj2*x596))+((sj2*x597))), ((((-1.0)*r02*sj2))+((cj2*x597))+((cj2*x596))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x598=(r01*sj1);
IkReal x599=((1.0)*cj2);
IkReal x600=(cj1*r00);
evalcond[0]=((((-1.0)*x598*x599))+((r02*sj2))+(((-1.0)*x599*x600))+(IKcos(j5)));
evalcond[1]=(((cj2*r02))+((sj2*x598))+(((-1.0)*(IKsin(j5))))+((sj2*x600)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x601=(r01*sj1);
IkReal x602=((1.0)*cj2);
IkReal x603=(cj1*r00);
CheckValue<IkReal> x604=IKPowWithIntegerCheck(cj4,-1);
if(!x604.valid){
continue;
}
if( IKabs((((cj2*r02))+((sj2*x601))+((sj2*x603)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x604.value)*(((((-1.0)*x602*x603))+((r02*sj2))+(((-1.0)*x601*x602)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((sj2*x601))+((sj2*x603))))+IKsqr(((x604.value)*(((((-1.0)*x602*x603))+((r02*sj2))+(((-1.0)*x601*x602))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((sj2*x601))+((sj2*x603))), ((x604.value)*(((((-1.0)*x602*x603))+((r02*sj2))+(((-1.0)*x601*x602))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x605=IKcos(j5);
IkReal x606=(r01*sj1);
IkReal x607=((1.0)*cj2);
IkReal x608=(cj1*r00);
IkReal x609=((1.0)*x605);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj4*x609)));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((sj2*x606))+((sj2*x608)));
evalcond[2]=(((r02*sj2))+(((-1.0)*cj4*x609))+(((-1.0)*x606*x607))+(((-1.0)*x607*x608)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x610=IKPowWithIntegerCheck(sj4,-1);
if(!x610.valid){
continue;
}
if( IKabs((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x610.value)*((((cj1*r01))+(((-1.0)*r00*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))))+IKsqr(((x610.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2))), ((x610.value)*((((cj1*r01))+(((-1.0)*r00*sj1))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x611=IKcos(j5);
IkReal x612=(r01*sj1);
IkReal x613=((1.0)*cj2);
IkReal x614=(cj1*r00);
IkReal x615=((1.0)*x611);
evalcond[0]=((((-1.0)*sj4*x615))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((cj2*r02))+(((-1.0)*(IKsin(j5))))+((sj2*x614))+((sj2*x612)));
evalcond[2]=((((-1.0)*x612*x613))+((r02*sj2))+(((-1.0)*cj4*x615))+(((-1.0)*x613*x614)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x616=((1.0)*r01);
if( IKabs(((((-1.0)*sj1*sj2*x616))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj1))+(((-1.0)*cj1*x616)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*sj2*x616))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))))+IKsqr((((r00*sj1))+(((-1.0)*cj1*x616))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj1*sj2*x616))+(((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))), (((r00*sj1))+(((-1.0)*cj1*x616))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(IKcos(j5)));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x617=((1.0)*sj1);
if( IKabs(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r01*sj2*x617)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*x617))+((cj1*r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r01*sj2*x617))))+IKsqr(((((-1.0)*r00*x617))+((cj1*r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*cj1*r00*sj2))+(((-1.0)*cj2*r02))+(((-1.0)*r01*sj2*x617))), ((((-1.0)*r00*x617))+((cj1*r01))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*(IKcos(j5)))));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((cj1*r00*sj2))+((r01*sj1*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x618=((1.0)*sj2);
IkReal x619=(cj1*r00);
IkReal x620=((1.0)*cj2);
IkReal x621=(r01*sj1);
if( IKabs(((((-1.0)*r02*x620))+(((-1.0)*x618*x619))+(((-1.0)*x618*x621)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x620*x621))+((r02*sj2))+(((-1.0)*x619*x620)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*x620))+(((-1.0)*x618*x619))+(((-1.0)*x618*x621))))+IKsqr(((((-1.0)*x620*x621))+((r02*sj2))+(((-1.0)*x619*x620))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r02*x620))+(((-1.0)*x618*x619))+(((-1.0)*x618*x621))), ((((-1.0)*x620*x621))+((r02*sj2))+(((-1.0)*x619*x620))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x622=(r01*sj1);
IkReal x623=((1.0)*cj2);
IkReal x624=(cj1*r00);
evalcond[0]=(((sj2*x624))+((sj2*x622))+(IKsin(j5))+((cj2*r02)));
evalcond[1]=((((-1.0)*x623*x624))+(((-1.0)*x622*x623))+(((-1.0)*(IKcos(j5))))+((r02*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x625=(cj1*r00);
IkReal x626=((1.0)*sj2);
IkReal x627=(r01*sj1);
if( IKabs(((((-1.0)*x625*x626))+(((-1.0)*x626*x627))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*x626))+((cj2*x627))+((cj2*x625)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x625*x626))+(((-1.0)*x626*x627))+(((-1.0)*cj2*r02))))+IKsqr(((((-1.0)*r02*x626))+((cj2*x627))+((cj2*x625))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x625*x626))+(((-1.0)*x626*x627))+(((-1.0)*cj2*r02))), ((((-1.0)*r02*x626))+((cj2*x627))+((cj2*x625))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x628=(r01*sj1);
IkReal x629=((1.0)*cj2);
IkReal x630=(cj1*r00);
evalcond[0]=(((sj2*x628))+(IKsin(j5))+((sj2*x630))+((cj2*r02)));
evalcond[1]=((((-1.0)*x629*x630))+(((-1.0)*x628*x629))+((r02*sj2))+(IKcos(j5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x631=((1.0)*sj2);
IkReal x632=(cj1*r00);
IkReal x633=((1.0)*cj2);
IkReal x634=(r01*sj1);
CheckValue<IkReal> x635=IKPowWithIntegerCheck(cj4,-1);
if(!x635.valid){
continue;
}
if( IKabs(((((-1.0)*x631*x632))+(((-1.0)*x631*x634))+(((-1.0)*r02*x633)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x635.value)*(((((-1.0)*x633*x634))+((r02*sj2))+(((-1.0)*x632*x633)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x631*x632))+(((-1.0)*x631*x634))+(((-1.0)*r02*x633))))+IKsqr(((x635.value)*(((((-1.0)*x633*x634))+((r02*sj2))+(((-1.0)*x632*x633))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*x631*x632))+(((-1.0)*x631*x634))+(((-1.0)*r02*x633))), ((x635.value)*(((((-1.0)*x633*x634))+((r02*sj2))+(((-1.0)*x632*x633))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x636=IKcos(j5);
IkReal x637=(r01*sj1);
IkReal x638=((1.0)*cj2);
IkReal x639=(cj1*r00);
evalcond[0]=(((sj4*x636))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=((IKsin(j5))+((sj2*x637))+((sj2*x639))+((cj2*r02)));
evalcond[2]=((((-1.0)*cj4*x636))+(((-1.0)*x637*x638))+(((-1.0)*x638*x639))+((r02*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x640=((1.0)*cj1);
CheckValue<IkReal> x641=IKPowWithIntegerCheck(sj4,-1);
if(!x641.valid){
continue;
}
if( IKabs(((((-1.0)*r00*sj2*x640))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x641.value)*((((r00*sj1))+(((-1.0)*r01*x640)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*sj2*x640))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))))+IKsqr(((x641.value)*((((r00*sj1))+(((-1.0)*r01*x640))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*r00*sj2*x640))+(((-1.0)*r01*sj1*sj2))+(((-1.0)*cj2*r02))), ((x641.value)*((((r00*sj1))+(((-1.0)*r01*x640))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x642=IKcos(j5);
IkReal x643=(r01*sj1);
IkReal x644=((1.0)*cj2);
IkReal x645=(cj1*r00);
evalcond[0]=(((sj4*x642))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=((IKsin(j5))+((cj2*r02))+((sj2*x645))+((sj2*x643)));
evalcond[2]=(((r02*sj2))+(((-1.0)*cj4*x642))+(((-1.0)*x644*x645))+(((-1.0)*x643*x644)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=cj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x646=(r01*sj1);
IkReal x647=((1.0)*cj2);
IkReal x648=(cj1*r00);
CheckValue<IkReal> x649=IKPowWithIntegerCheck(sj3,-1);
if(!x649.valid){
continue;
}
if( IKabs(((x649.value)*((((cj2*r02))+((sj2*x646))+((sj2*x648)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x647*x648))+(((-1.0)*x646*x647))+((r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x649.value)*((((cj2*r02))+((sj2*x646))+((sj2*x648))))))+IKsqr(((((-1.0)*x647*x648))+(((-1.0)*x646*x647))+((r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x649.value)*((((cj2*r02))+((sj2*x646))+((sj2*x648))))), ((((-1.0)*x647*x648))+(((-1.0)*x646*x647))+((r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x650=IKsin(j5);
IkReal x651=(r01*sj1);
IkReal x652=((1.0)*cj2);
IkReal x653=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x650)));
evalcond[1]=((((-1.0)*sj3*x650))+((cj2*r02))+((sj2*x651))+((sj2*x653)));
evalcond[2]=((((-1.0)*x651*x652))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*x652*x653)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x654=((1.0)*r01);
CheckValue<IkReal> x655=IKPowWithIntegerCheck(cj3,-1);
if(!x655.valid){
continue;
}
if( IKabs(((x655.value)*((((r00*sj1))+(((-1.0)*cj1*x654)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj2*sj1*x654))+((r02*sj2))+(((-1.0)*cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x655.value)*((((r00*sj1))+(((-1.0)*cj1*x654))))))+IKsqr(((((-1.0)*cj2*sj1*x654))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x655.value)*((((r00*sj1))+(((-1.0)*cj1*x654))))), ((((-1.0)*cj2*sj1*x654))+((r02*sj2))+(((-1.0)*cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x656=IKsin(j5);
IkReal x657=(r01*sj1);
IkReal x658=((1.0)*cj2);
IkReal x659=(cj1*r00);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+((cj3*x656)));
evalcond[1]=((((-1.0)*sj3*x656))+((cj2*r02))+((sj2*x659))+((sj2*x657)));
evalcond[2]=((((-1.0)*x657*x658))+(((-1.0)*(IKcos(j5))))+((r02*sj2))+(((-1.0)*x658*x659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=cj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=sj3;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x660=(r01*sj1);
IkReal x661=(cj1*r00);
CheckValue<IkReal> x662=IKPowWithIntegerCheck(sj3,-1);
if(!x662.valid){
continue;
}
if( IKabs(((x662.value)*((((cj2*r02))+((sj2*x660))+((sj2*x661)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*x661))+((cj2*x660))+(((-1.0)*r02*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x662.value)*((((cj2*r02))+((sj2*x660))+((sj2*x661))))))+IKsqr((((cj2*x661))+((cj2*x660))+(((-1.0)*r02*sj2))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x662.value)*((((cj2*r02))+((sj2*x660))+((sj2*x661))))), (((cj2*x661))+((cj2*x660))+(((-1.0)*r02*sj2))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x663=IKsin(j5);
IkReal x664=(r01*sj1);
IkReal x665=((1.0)*cj2);
IkReal x666=(cj1*r00);
evalcond[0]=(((cj3*x663))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=((((-1.0)*x665*x666))+((r02*sj2))+(IKcos(j5))+(((-1.0)*x664*x665)));
evalcond[2]=((((-1.0)*sj3*x663))+((cj2*r02))+((sj2*x664))+((sj2*x666)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x667=IKPowWithIntegerCheck(cj3,-1);
if(!x667.valid){
continue;
}
if( IKabs(((x667.value)*((((r00*sj1))+(((-1.0)*cj1*r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x667.value)*((((r00*sj1))+(((-1.0)*cj1*r01))))))+IKsqr((((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x667.value)*((((r00*sj1))+(((-1.0)*cj1*r01))))), (((cj2*r01*sj1))+(((-1.0)*r02*sj2))+((cj1*cj2*r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x668=IKsin(j5);
IkReal x669=(r01*sj1);
IkReal x670=((1.0)*cj2);
IkReal x671=(cj1*r00);
evalcond[0]=(((cj3*x668))+((cj1*r01))+(((-1.0)*r00*sj1)));
evalcond[1]=(((r02*sj2))+(((-1.0)*x670*x671))+(IKcos(j5))+(((-1.0)*x669*x670)));
evalcond[2]=(((sj2*x671))+(((-1.0)*sj3*x668))+((cj2*r02))+((sj2*x669)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x679=IKPowWithIntegerCheck(cj4,-1);
if(!x679.valid){
continue;
}
IkReal x672=x679.value;
IkReal x673=(cj4*sj2);
IkReal x674=(cj1*r00);
IkReal x675=(r01*sj1);
IkReal x676=(cj3*sj4);
IkReal x677=(r02*sj2);
IkReal x678=((1.0)*cj2);
CheckValue<IkReal> x680=IKPowWithIntegerCheck(sj3,-1);
if(!x680.valid){
continue;
}
if( IKabs((x672*(x680.value)*((((x673*x674))+((x673*x675))+((cj2*x675*x676))+((cj2*cj4*r02))+(((-1.0)*x676*x677))+((cj2*x674*x676)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x672*(((((-1.0)*x675*x678))+x677+(((-1.0)*x674*x678)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x672*(x680.value)*((((x673*x674))+((x673*x675))+((cj2*x675*x676))+((cj2*cj4*r02))+(((-1.0)*x676*x677))+((cj2*x674*x676))))))+IKsqr((x672*(((((-1.0)*x675*x678))+x677+(((-1.0)*x674*x678))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x672*(x680.value)*((((x673*x674))+((x673*x675))+((cj2*x675*x676))+((cj2*cj4*r02))+(((-1.0)*x676*x677))+((cj2*x674*x676))))), (x672*(((((-1.0)*x675*x678))+x677+(((-1.0)*x674*x678))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x681=IKcos(j5);
IkReal x682=IKsin(j5);
IkReal x683=(r01*sj1);
IkReal x684=((1.0)*cj2);
IkReal x685=(cj1*r00);
IkReal x686=((1.0)*x681);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj3*sj4*x686))+((cj3*x682)));
evalcond[1]=((((-1.0)*cj4*x686))+((r02*sj2))+(((-1.0)*x684*x685))+(((-1.0)*x683*x684)));
evalcond[2]=((((-1.0)*cj3*sj4*x686))+((sj2*x683))+((sj2*x685))+((cj2*r02))+(((-1.0)*sj3*x682)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x693=IKPowWithIntegerCheck(cj4,-1);
if(!x693.valid){
continue;
}
IkReal x687=x693.value;
IkReal x688=((1.0)*r01);
IkReal x689=(cj2*sj1);
IkReal x690=(r02*sj2);
IkReal x691=(sj3*sj4);
IkReal x692=((1.0)*cj1*cj2*r00);
CheckValue<IkReal> x694=IKPowWithIntegerCheck(cj3,-1);
if(!x694.valid){
continue;
}
if( IKabs((x687*(x694.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x688))+((x690*x691))+(((-1.0)*x688*x689*x691))+(((-1.0)*x691*x692)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x687*(((((-1.0)*x688*x689))+x690+(((-1.0)*x692)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x687*(x694.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x688))+((x690*x691))+(((-1.0)*x688*x689*x691))+(((-1.0)*x691*x692))))))+IKsqr((x687*(((((-1.0)*x688*x689))+x690+(((-1.0)*x692))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x687*(x694.value)*((((cj4*r00*sj1))+(((-1.0)*cj1*cj4*x688))+((x690*x691))+(((-1.0)*x688*x689*x691))+(((-1.0)*x691*x692))))), (x687*(((((-1.0)*x688*x689))+x690+(((-1.0)*x692))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x695=IKcos(j5);
IkReal x696=IKsin(j5);
IkReal x697=(r01*sj1);
IkReal x698=((1.0)*cj2);
IkReal x699=(cj1*r00);
IkReal x700=((1.0)*x695);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj3*sj4*x700))+((cj3*x696)));
evalcond[1]=((((-1.0)*x697*x698))+((r02*sj2))+(((-1.0)*x698*x699))+(((-1.0)*cj4*x700)));
evalcond[2]=((((-1.0)*sj3*x696))+((cj2*r02))+(((-1.0)*cj3*sj4*x700))+((sj2*x697))+((sj2*x699)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x701=(cj2*r02);
IkReal x702=(cj1*r01);
IkReal x703=(sj1*sj3);
IkReal x704=(r01*sj2);
IkReal x705=(cj3*sj1);
IkReal x706=(cj1*r00*sj2);
CheckValue<IkReal> x707=IKPowWithIntegerCheck(sj4,-1);
if(!x707.valid){
continue;
}
if( IKabs((((x703*x704))+((r00*x705))+((sj3*x706))+((sj3*x701))+(((-1.0)*cj3*x702)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x707.value)*(((((-1.0)*r00*x703))+((sj3*x702))+((x704*x705))+((cj3*x701))+((cj3*x706)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x703*x704))+((r00*x705))+((sj3*x706))+((sj3*x701))+(((-1.0)*cj3*x702))))+IKsqr(((x707.value)*(((((-1.0)*r00*x703))+((sj3*x702))+((x704*x705))+((cj3*x701))+((cj3*x706))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((x703*x704))+((r00*x705))+((sj3*x706))+((sj3*x701))+(((-1.0)*cj3*x702))), ((x707.value)*(((((-1.0)*r00*x703))+((sj3*x702))+((x704*x705))+((cj3*x701))+((cj3*x706))))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x708=IKcos(j5);
IkReal x709=IKsin(j5);
IkReal x710=(r01*sj1);
IkReal x711=((1.0)*cj2);
IkReal x712=(cj1*r00);
IkReal x713=((1.0)*x708);
evalcond[0]=(((cj1*r01))+(((-1.0)*r00*sj1))+(((-1.0)*sj3*sj4*x713))+((cj3*x709)));
evalcond[1]=((((-1.0)*x711*x712))+(((-1.0)*x710*x711))+((r02*sj2))+(((-1.0)*cj4*x713)));
evalcond[2]=((((-1.0)*sj3*x709))+((sj2*x710))+((sj2*x712))+((cj2*r02))+(((-1.0)*cj3*sj4*x713)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - komodo_torso (a61c937052cde5e6c1705b0db6a91e59)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
